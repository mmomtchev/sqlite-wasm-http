{"version":3,"file":"559.bundle.js","mappings":"uBAAIA,ECAAC,E,8BCCG,MAAMC,EAAiB,CAC1BC,QAAS,IACTC,YAAa,KACbC,UAAW,KACXC,QAAS,CAAC,GAGP,IAAIC,GACX,SAAWA,GACPA,EAAKA,EAAc,QAAI,UAAY,UACnCA,EAAKA,EAAgB,UAAI,UAAY,WACxC,CAHD,CAGGA,EAAOA,IAASA,EAAO,CAAC,IAC3B,MAAMC,EAAuD,IAEzD,EACSC,EAAW,CAAC,UAAW,MAAO,QAAS,QACvCC,EAAQ,CAAC,EACtB,IAAK,MAAMC,KAAKF,EACZC,EAAMC,GAAKH,EAAaI,SAASD,GAC7BE,QAAQH,MAAMI,KAAKD,SACnB,KAAe,EClBvB,MAAME,EAAa,WACf,MAAMC,EAAK,IAAIC,YAAY,GACrBC,EAAK,IAAIC,WAAWH,GACpBI,EAAM,IAAIC,YAAYL,GAI5B,GAHAE,EAAG,GAAK,IACRA,EAAG,GAAK,GAEM,OAAVE,EAAI,GAEJ,OADAV,EAAA,QAAiB,yBACV,EAGX,GAAc,MAAVU,EAAI,GAEJ,OADAV,EAAA,QAAiB,4BACV,EAEX,MAAM,IAAIY,MAAM,kCAAkCF,IACrD,CAjBkB,GCDnB,IAAIG,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAU1B,KAAK+B,GAAS,CAAE,MAAOE,GAAKJ,EAAOI,EAAI,CAAE,CAC1F,SAASC,EAASH,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,GAAS,CAAE,MAAOE,GAAKJ,EAAOI,EAAI,CAAE,CAC7F,SAASD,EAAKG,GAJlB,IAAeJ,EAIaI,EAAOC,KAAOR,EAAQO,EAAOJ,QAJ1CA,EAIyDI,EAAOJ,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,EAAQ,KAIjBM,KAAKP,EAAWI,EAAW,CAC7GF,GAAMN,EAAYA,EAAUY,MAAMf,EAASC,GAAc,KAAKxB,OAClE,GACJ,EAKA,IAAIuC,EAEJ,MAAMC,EAAY,CAAC,EACbC,EAAQ,IAAI,IAAS,CACvBC,IAAK,KAWT,IAAIC,EACAC,EAAS,EACb,MAAMC,EAAsB,CAExBC,MAAO,SAAUC,GACb,OAAOzB,EAAU0B,UAAM,OAAQ,GAAQ,YACnC,IAAIC,EAAQR,EAAMS,IAAIH,EAAII,KAG1B,OAFIF,aAAiBtB,UACjBsB,QAAcA,QACJG,IAAVH,IAGJA,EAAQI,MAAMN,EAAII,IAAK,CAAEG,OAAQ,OAAQjD,QAASkD,OAAOC,OAAO,CAAC,EAAGjB,aAAyC,EAASA,EAAQlC,WACzHgC,MAAMoB,IACP,IAAIC,EAMJ,MAL0C,UAAtCD,EAAKpD,QAAQ6C,IAAI,kBACjBtC,QAAQ+C,KAAK,cAAcZ,EAAII,wMAI5B,CACHA,IAAKJ,EAAII,IACTS,GAAIhB,IACJiB,KAAMC,OAAqD,QAA7CJ,EAAKD,EAAKpD,QAAQ6C,IAAI,yBAAsC,IAAPQ,EAAgBA,EAAK,GAExFK,SAAU,KACb,IAELtB,EAAMuB,IAAIjB,EAAII,IAAKF,GAEnBR,EAAMuB,IAAIjB,EAAII,UAAWF,IApBd,CAsBf,GACJ,EAEAgB,QAAS,SAAUlB,EAAKmB,GACpB,OAAO5C,EAAU0B,UAAM,OAAQ,GAAQ,YACnC,MAAMb,EAAS,IAAIgC,YAAYD,EAASE,IAAK,EAAG,GAChD,IACI,MAAMC,QAAUxB,EAAoBC,MAAMC,EAAKmB,GAE3C/B,EAAO,GADD,IAANkC,EACY,EAGA,CAEpB,CACA,MAAOX,GACHvB,EAAO,GAAK,CAChB,CACA,OAAO,CACX,GACJ,EACAmC,MAAO,SAAUvB,EAAKmB,GAClB,IAAIR,EAAIa,EAAIC,EACZ,OAAOlD,EAAU0B,UAAM,OAAQ,GAAQ,YACnC,IAAIC,EAAQR,EAAMS,IAAIH,EAAII,KAC1B,IAAKF,EACD,MAAM,IAAI5B,MAAM,QAAQ0B,EAAII,gBAGhC,GAFIF,aAAiBtB,UACjBsB,QAAcA,QACJG,IAAVL,EAAI0B,QAAkCrB,IAAfL,EAAI2B,OAC3B,MAAM,IAAIrD,MAAM,+BACpB,IAAK4B,EAAMc,SAAU,CAGjBd,EAAMc,SAAW,KACjB,MAAMY,EAAiB,IAAI3D,YAAY,GACjCqD,QAAUxB,EAAoByB,MAAM,CAAEvB,IAAK,QAASI,IAAKJ,EAAII,IAAKuB,OAAQZ,OAAO,IAAKW,EAAG,GAAK,CAAEG,OAAQ,IAAI1D,WAAWyD,KACvHE,EAAW,IAAIzD,YAAYuD,GACjC,GAAU,IAANN,EACA,OAAOA,EASX,GDzFT,SAAgBS,GACnB,GAAIhE,EACA,IAAK,IAAIiE,EAAI,EAAGA,EAAID,EAAKE,OAAQD,IAC7BD,EAAKC,IAAiB,MAAVD,EAAKC,KAAgB,GAAiB,IAAVD,EAAKC,KAAgB,CAGzE,CC2EgBE,CAAOJ,GACP5B,EAAMc,SAAWc,EAAS,GAC1BpE,EAAA,IAAa,gBAAgBwC,EAAMc,YACb,MAAlBd,EAAMc,WAENnD,QAAQ+C,KAAK,iBAAiBZ,EAAII,UAAUF,EAAMc,sCAClDpB,EAAMuC,OAAOjC,EAAMW,GAAK,OAExBX,EAAMc,UAA6F,QAAhFL,EAAKnB,aAAyC,EAASA,EAAQpC,mBAAgC,IAAPuD,EAAgBA,EAAK,eAChI,MAAM,IAAIrC,MAAM,GAAG4B,EAAMc,2CAC+D,QAAhFQ,EAAKhC,aAAyC,EAASA,EAAQpC,mBAAgC,IAAPoE,EAAgBA,EAAK,gBAC7H,CACA,MAAMR,EAAWD,OAAOb,EAAMc,UACxBoB,EAAMrB,OAAOf,EAAI0B,GACjBW,EAAOrC,EAAI2B,OAASX,EACtBqB,EAAOrB,IAAahB,EAAI2B,QACxBjE,EAAA,IAAa,cAAcsC,EAAI2B,UAAU3B,EAAI0B,yBACjD,IAAIY,EAAYD,EAAOrB,EACvB,GAAIsB,EAAYtB,EAAWhB,EAAI2B,OAASS,EACpC,MAAM,IAAI9D,MAAM,cAAc0B,EAAI2B,UAAU3B,EAAI0B,kCACpD,MAAMa,EAAUrC,EAAMW,GAAK,IAAMwB,EACjC,IAAIN,EAAOnC,EAAMO,IAAIoC,GAIrB,GAHIR,aAAgBnD,UAEhBmD,QAAaA,GACG,iBAATA,EAAmB,CAC1BrE,EAAA,MAAe,sCAAsCsC,EAAII,OAAOiC,KAEhE,MAAMG,EAAezB,OAAOgB,GAAQf,EACpCe,EAAOnC,EAAMO,IAAID,EAAMW,GAAK,IAAMkB,GAC9BA,aAAgBnD,UAChBmD,QAAaA,GACbA,aAAgB5D,WAKhBmE,EAAYE,EAGZT,OAAO1B,CAEf,CACA,QAAoB,IAAT0B,EAAsB,CAC7BrE,EAAA,MAAe,kBAAkBsC,EAAII,OAAOiC,KAC5C,IAAII,EAAYvC,EAAMc,SAGlB0B,EAAOL,EAAO,GAAKzC,EAAMO,IAAID,EAAMW,GAAK,KAAO8B,OAAON,GAAQ,IAC9DK,IACIA,aAAgB9D,UAChB8D,QAAaA,GACG,iBAATA,IACPA,EAAO9C,EAAMO,IAAID,EAAMW,GAAK,IAAM6B,IAClCA,aAAgB9D,UAChB8D,QAAaA,GACbA,aAAgBvE,aAEhBsE,EAA8B,EAAlBC,EAAKE,WACjBlF,EAAA,MAAe,kCAAkC+E,OAGzD,MAAMI,EAAQJ,EAAYvC,EAAMc,SAEhCtD,EAAA,KAAc,oBAAoB2E,aAAgBI,iBAAyBH,KAC3E,MAAMQ,EAAOxC,MAAMN,EAAII,IAAK,CACxBG,OAAQ,MACRjD,QAASkD,OAAOC,OAAOD,OAAOC,OAAO,CAAC,EAAiF,QAA5EgB,EAAKjC,aAAyC,EAASA,EAAQlC,eAA4B,IAAPmE,EAAgBA,EAAK,WAAkC,CAAE,MAAS,SAASa,KAAaA,EAAYvB,OAAO0B,EAAY,SAErPnD,MAAMgC,GAAMA,EAAEyB,gBACdzD,MAAMgC,GAAM,IAAInD,WAAWmD,KAGhC1B,EAAMqB,IAAIsB,EAASO,GAEnB,IAAK,IAAId,EAAIW,OAAON,GAAQ,EAAGL,EAAIW,OAAON,GAAQQ,EAAOb,IACrDpC,EAAMqB,IAAIf,EAAMW,GAAK,IAAMmB,EAAGc,EAAKxD,MAAK,IAAMqD,OAAON,MAGzD,GADAN,QAAae,IACPf,aAAgB5D,aAA+B,IAAhB4D,EAAKE,OACtC,MAAM,IAAI3D,MAAM,mCAAmC0E,KAAKC,UAAUH,MAEtElD,EAAMqB,IAAIsB,EAASR,GAEnB,IAAK,IAAIC,EAAIW,OAAON,GAAQ,EAAGL,EAAIW,OAAON,GAAQQ,EAAOb,IACrDpC,EAAMqB,IAAIf,EAAMW,GAAK,IAAMmB,EAAGW,OAAON,GAE7C,MAEI3E,EAAA,MAAe,iBAAiBsC,EAAII,OAAOiC,KAE/C,MAAMa,EAAaP,OAAO3C,EAAI2B,OAASW,GAEvC,OADAnB,EAASU,OAAOZ,IAAIc,EAAKoB,SAASD,EAAYA,EAAalD,EAAI0B,IACxD,CACX,GACJ,EAEA0B,UAAW,SAAUpD,EAAKmB,GACtB,OAAO5C,EAAU0B,UAAM,OAAQ,GAAQ,YACnC,IAAIC,EAAQR,EAAMS,IAAIH,EAAII,KAC1B,IAAKF,EACD,MAAM,IAAI5B,MAAM,QAAQ0B,EAAIqD,gBAKhC,OAJInD,aAAiBtB,UACjBsB,QAAcA,GACN,IAAIoD,cAAcnC,EAASE,IAAK,EAAG,GAC3C,GAAKnB,EAAMY,KACR,CACX,GACJ,GAEJ,SAASyC,GAAY,KAAExB,IACnB,OAAOxD,EAAU0B,UAAM,OAAQ,GAAQ,YAEnC,IAAIqB,EADJ5D,EAAA,QAAiB,4BAA6BuC,KAAM8B,GAEpD,IACIT,QAAUxB,EAAoBiC,EAAK/B,KAAK+B,EAAM9B,MAC9CvC,EAAA,QAAiB,uBAAwBuC,KAAMqB,GAC/CkC,QAAQC,MAAMxD,KAAKyD,KAAM,EAAGpC,EAChC,CACA,MAAOpC,GACHrB,QAAQ8F,MAAMzE,GACdsE,QAAQC,MAAMxD,KAAKyD,KAAM,EAAG,EAChC,CACAF,QAAQI,OAAO3D,KAAKyD,KAAM,EAC9B,GACJ,CAgCA,GA/BAG,WAAWC,UAAY,EAAG/B,WACtB,IAAIpB,EAAIa,EAAIC,EAAIsC,EAEhB,OADArG,EAAA,QAAiB,+BAAgCqE,GACzCA,EAAK/B,KACT,IAAK,YACD,CACI,MAAMqB,EAAM,IAAI2C,mBAAoG,QAAhFrD,EAAKnB,aAAyC,EAASA,EAAQpC,mBAAgC,IAAPuD,EAAgBA,EAAK,eAC3IsD,WAAWC,mBACXR,EAAO,IAAIO,WAAW5C,EAAuF,QAAhFG,EAAKhC,aAAyC,EAASA,EAAQpC,mBAAgC,IAAPoE,EAAgBA,EAAK,eAC1IK,EAAS,IAAI1D,WAAWkD,EAAK,EAAqF,QAAhFI,EAAKjC,aAAyC,EAASA,EAAQpC,mBAAgC,IAAPqE,EAAgBA,EAAK,eACrJ+B,QAAQC,MAAMC,EAAM,EAAG,aACvBjE,EAAUsC,EAAKlB,IAAM,CAAEA,GAAIkB,EAAKlB,GAAIsD,KAAMpC,EAAKoC,KAAM9C,MAAKqC,OAAM7B,UAChEE,EAAKoC,KAAKL,UAAYP,EAAYzF,KAAK2B,EAAUsC,EAAKlB,KACtDuD,YAAY,CAAEpE,IAAK,MAAOa,GAAIkB,EAAKlB,GAAIQ,MAAKqC,QAChD,CACA,MACJ,IAAK,OACDlE,EAAUuC,EAAKvC,QACfI,EAAQ,IAAI,IAAS,CACjByE,QAA0J,MAAjE,QAA9EN,EAAKvE,aAAyC,EAASA,EAAQnC,iBAA8B,IAAP0G,EAAgBA,EAAK,aACtHO,gBAAkBtF,IAAY,IAAI2B,EAAI,OAAmC,QAA3BA,EAAK3B,EAAM4D,kBAA+B,IAAPjC,EAAgBA,EAAK,CAAC,IAE3G,MACJ,IAAK,QACDyD,YAAY,CAAEpE,IAAK,QACnBuE,QACA,MACJ,QACI,MAAM,IAAIjG,MAAM,wCAAwCyD,KAChE,EAE6B,oBAAtBiC,kBACP,MAAM,IAAI1F,MAAM,+L,GCnQhBkG,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBrE,IAAjBsE,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,EAAyBE,GAAY,CAGjDE,QAAS,CAAC,GAOX,OAHAE,EAAoBJ,GAAUG,EAAQA,EAAOD,QAASH,GAG/CI,EAAOD,OACf,CAGAH,EAAoBM,EAAID,EAGxBL,EAAoBO,EAAI,KAGvB,IAAIC,EAAsBR,EAAoBS,OAAE7E,EAAW,CAAC,MAAM,IAAOoE,EAAoB,OAE7F,OADsBA,EAAoBS,EAAED,EAClB,ELjCvBjI,EAAW,GACfyH,EAAoBS,EAAI,CAAC9F,EAAQ+F,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAeC,IACnB,IAASvD,EAAI,EAAGA,EAAIhF,EAASiF,OAAQD,IAAK,CAGzC,IAFA,IAAKmD,EAAUC,EAAIC,GAAYrI,EAASgF,GACpCjD,GAAY,EACPyG,EAAI,EAAGA,EAAIL,EAASlD,OAAQuD,MACpB,EAAXH,GAAsBC,GAAgBD,IAAa7E,OAAOiF,KAAKhB,EAAoBS,GAAGQ,OAAOC,GAASlB,EAAoBS,EAAES,GAAKR,EAASK,MAC9IL,EAASS,OAAOJ,IAAK,IAErBzG,GAAY,EACTsG,EAAWC,IAAcA,EAAeD,IAG7C,GAAGtG,EAAW,CACb/B,EAAS4I,OAAO5D,IAAK,GACrB,IAAIV,EAAI8D,SACE/E,IAANiB,IAAiBlC,EAASkC,EAC/B,CACD,CACA,OAAOlC,CAnBP,CAJCiG,EAAWA,GAAY,EACvB,IAAI,IAAIrD,EAAIhF,EAASiF,OAAQD,EAAI,GAAKhF,EAASgF,EAAI,GAAG,GAAKqD,EAAUrD,IAAKhF,EAASgF,GAAKhF,EAASgF,EAAI,GACrGhF,EAASgF,GAAK,CAACmD,EAAUC,EAAIC,EAqBjB,EMzBdZ,EAAoB9G,EAAI,CAACiH,EAASiB,KACjC,IAAI,IAAIF,KAAOE,EACXpB,EAAoBqB,EAAED,EAAYF,KAASlB,EAAoBqB,EAAElB,EAASe,IAC5EnF,OAAOuF,eAAenB,EAASe,EAAK,CAAEK,YAAY,EAAM7F,IAAK0F,EAAWF,IAE1E,ECNDlB,EAAoBwB,EAAI,CAAC,EAGzBxB,EAAoBvF,EAAKgH,GACjBtH,QAAQuH,IAAI3F,OAAOiF,KAAKhB,EAAoBwB,GAAGG,QAAO,CAACC,EAAUV,KACvElB,EAAoBwB,EAAEN,GAAKO,EAASG,GAC7BA,IACL,KCNJ5B,EAAoB6B,EAAKJ,GAEZA,EAAU,aCHvBzB,EAAoB8B,EAAI,WACvB,GAA0B,iBAAf1C,WAAyB,OAAOA,WAC3C,IACC,OAAO5D,MAAQ,IAAIuG,SAAS,cAAb,EAChB,CAAE,MAAOtH,GACR,GAAsB,iBAAXuH,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBhC,EAAoBqB,EAAI,CAACY,EAAKC,IAAUnG,OAAOoG,UAAUC,eAAeC,KAAKJ,EAAKC,G,MCAlF,IAAII,EACAtC,EAAoB8B,EAAES,gBAAeD,EAAYtC,EAAoB8B,EAAEU,SAAW,IACtF,IAAIC,EAAWzC,EAAoB8B,EAAEW,SACrC,IAAKH,GAAaG,IACbA,EAASC,gBACZJ,EAAYG,EAASC,cAAcC,MAC/BL,GAAW,CACf,IAAIM,EAAUH,EAASI,qBAAqB,UACzCD,EAAQpF,SAAQ8E,EAAYM,EAAQA,EAAQpF,OAAS,GAAGmF,IAC5D,CAID,IAAKL,EAAW,MAAM,IAAIzI,MAAM,yDAChCyI,EAAYA,EAAUQ,QAAQ,OAAQ,IAAIA,QAAQ,QAAS,IAAIA,QAAQ,YAAa,KACpF9C,EAAoB+C,EAAIT,C,WCXxB,IAAIU,EAAkB,CACrB,IAAK,GAgBNhD,EAAoBwB,EAAEjE,EAAI,CAACkE,EAASG,KAE/BoB,EAAgBvB,IAElBc,cAAcvC,EAAoB+C,EAAI/C,EAAoB6B,EAAEJ,GAE9D,EAGD,IAAIwB,EAAqBC,KAAmC,6BAAIA,KAAmC,8BAAK,GACpGC,EAA6BF,EAAmBG,KAAK/J,KAAK4J,GAC9DA,EAAmBG,KAvBC9F,IACnB,IAAKoD,EAAU2C,EAAaC,GAAWhG,EACvC,IAAI,IAAI2C,KAAYoD,EAChBrD,EAAoBqB,EAAEgC,EAAapD,KACrCD,EAAoBM,EAAEL,GAAYoD,EAAYpD,IAIhD,IADGqD,GAASA,EAAQtD,GACdU,EAASlD,QACdwF,EAAgBtC,EAAS6C,OAAS,EACnCJ,EAA2B7F,EAAK,C,KXnB7B9E,EAAOwH,EAAoBO,EAC/BP,EAAoBO,EAAI,IAChBP,EAAoBvF,EAAE,KAAKI,KAAKrC,GYDdwH,EAAoBO,G","sources":["webpack://sqlite-wasm-http/webpack/runtime/chunk loaded","webpack://sqlite-wasm-http/webpack/runtime/startup chunk dependencies","webpack://sqlite-wasm-http/./dist/vfs-http-types.js","webpack://sqlite-wasm-http/./dist/endianness.js","webpack://sqlite-wasm-http/./dist/vfs-http-worker.js","webpack://sqlite-wasm-http/webpack/bootstrap","webpack://sqlite-wasm-http/webpack/runtime/define property getters","webpack://sqlite-wasm-http/webpack/runtime/ensure chunk","webpack://sqlite-wasm-http/webpack/runtime/get javascript chunk filename","webpack://sqlite-wasm-http/webpack/runtime/global","webpack://sqlite-wasm-http/webpack/runtime/hasOwnProperty shorthand","webpack://sqlite-wasm-http/webpack/runtime/publicPath","webpack://sqlite-wasm-http/webpack/runtime/importScripts chunk loading","webpack://sqlite-wasm-http/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(842).then(next);\n};","var _a;\nexport const defaultOptions = {\n    timeout: 20000,\n    maxPageSize: 4096,\n    cacheSize: 1024,\n    headers: {}\n};\n// These must be different from any SQLite CAPI codes\nexport var SYNC;\n(function (SYNC) {\n    SYNC[SYNC[\"WORKMSG\"] = 16777215] = \"WORKMSG\";\n    SYNC[SYNC[\"HANDSHAKE\"] = 16777214] = \"HANDSHAKE\";\n})(SYNC = SYNC || (SYNC = {}));\nconst debugOptions = (typeof SQLITE_DEBUG !== 'undefined' && SQLITE_DEBUG) ||\n    (typeof process !== 'undefined' && typeof ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.SQLITE_DEBUG) !== 'undefined' && process.env.SQLITE_DEBUG) ||\n    '';\nexport const debugSys = ['threads', 'vfs', 'cache', 'http'];\nexport const debug = {};\nfor (const d of debugSys) {\n    debug[d] = debugOptions.includes(d) ?\n        console.debug.bind(console) :\n        () => undefined;\n}\n//# sourceMappingURL=vfs-http-types.js.map","// Procedures for changing the byte sex\n// SQLite is always Big-Endian, JS follows the platform, which is Little-Endian on x86\nimport { debug } from './vfs-http-types.js';\nconst swapNeeded = (function () {\n    const ab = new ArrayBuffer(2);\n    const u8 = new Uint8Array(ab);\n    const u16 = new Uint16Array(ab);\n    u8[0] = 0xF0;\n    u8[1] = 0x0D;\n    // Big\n    if (u16[0] == 0xF00D) {\n        debug['threads']('System is Big-Endian');\n        return false;\n    }\n    // Little\n    if (u16[0] == 0x0DF0) {\n        debug['threads']('System is Little-Endian');\n        return true;\n    }\n    throw new Error(`Failed determining endianness: ${u16}`);\n})();\nexport function ntoh16(data) {\n    if (swapNeeded) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = ((data[i] & 0xFF00) >> 8) | ((data[i] & 0x00FF) << 8);\n        }\n    }\n}\n//# sourceMappingURL=endianness.js.map","// This is the entry point for an HTTP backend thread\n// It can serve multiple SQLite worker threads\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport LRUCache from 'lru-cache';\nimport * as VFSHTTP from './vfs-http-types.js';\nimport { ntoh16 } from './endianness.js';\nimport { debug } from './vfs-http-types.js';\nlet options;\n// The set of sqlite Workers that use this backend\nconst consumers = {};\nconst files = new LRUCache({\n    max: 32\n});\n// The entry for a given page can be either the page itself\n// or the number of the page that has the parent super-page\n// Here is an example of a cache structure (indexed by the URL + page number)\n// URL|0 -> Uint8Array(page)                     # This page is in cache\n// URL|1 -> undefined                            # These two\n// URL|2 -> undefined                            # are not\n// URL|3 -> Promise<Uint8Array(page * 2)>        # This is a currently downloading 2-page segment\n// URL|4 -> Promise<3>                           # This references the previous one\n// URL|5 -> 2                                    # An invalid stale entry that will be overwritten\nlet cache;\nlet nextId = 1;\nconst backendAsyncMethods = {\n    // HTTP is a stateless protocol, so xOpen means verify if the URL is valid\n    xOpen: function (msg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let entry = files.get(msg.url);\n            if (entry instanceof Promise)\n                entry = yield entry;\n            if (entry !== undefined)\n                return 0;\n            // Set a promise for the next opener of the same file to await upon\n            entry = fetch(msg.url, { method: 'HEAD', headers: Object.assign({}, options === null || options === void 0 ? void 0 : options.headers) })\n                .then((head) => {\n                var _a;\n                if (head.headers.get('Accept-Ranges') !== 'bytes') {\n                    console.warn(`Server for ${msg.url} does not advertise 'Accept-Ranges'. ` +\n                        'If the server supports it, in order to remove this message, add \"Accept-Ranges: bytes\". ' +\n                        'Additionally, if using CORS, add \"Access-Control-Expose-Headers: *\".');\n                }\n                return {\n                    url: msg.url,\n                    id: nextId++,\n                    size: BigInt((_a = head.headers.get('Content-Length')) !== null && _a !== void 0 ? _a : 0),\n                    // This will be determined on the first read\n                    pageSize: null\n                };\n            });\n            files.set(msg.url, entry);\n            // Replace it with the actual entry once resolved\n            files.set(msg.url, yield entry);\n            return 0;\n        });\n    },\n    // There is no real difference between xOpen and xAccess, only the semantics differ\n    xAccess: function (msg, consumer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = new Uint32Array(consumer.shm, 0, 1);\n            try {\n                const r = yield backendAsyncMethods.xOpen(msg, consumer);\n                if (r === 0) {\n                    result[0] = 1;\n                }\n                else {\n                    result[0] = 0;\n                }\n            }\n            catch (_a) {\n                result[0] = 0;\n            }\n            return 0;\n        });\n    },\n    xRead: function (msg, consumer) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            let entry = files.get(msg.url);\n            if (!entry)\n                throw new Error(`File ${msg.url} not open`);\n            if (entry instanceof Promise)\n                entry = yield entry;\n            if (msg.n === undefined || msg.offset === undefined)\n                throw new Error('Mandatory arguments missing');\n            if (!entry.pageSize) {\n                // Determine the page size if we don't know it\n                // It is in two big-endian bytes at offset 16 in what is always the first page\n                entry.pageSize = 1024;\n                const pageDataBuffer = new ArrayBuffer(2);\n                const r = yield backendAsyncMethods.xRead({ msg: 'xRead', url: msg.url, offset: BigInt(16), n: 2 }, { buffer: new Uint8Array(pageDataBuffer) });\n                const pageData = new Uint16Array(pageDataBuffer);\n                if (r !== 0)\n                    return r;\n                ntoh16(pageData);\n                entry.pageSize = pageData[0];\n                debug['vfs'](`page size is ${entry.pageSize}`);\n                if (entry.pageSize != 1024) {\n                    // If the page size is not 1024 we can't keep this \"page\" in the cache\n                    console.warn(`Page size for ${msg.url} is ${entry.pageSize}, recommended size is 1024`);\n                    cache.delete(entry.id + '|0');\n                }\n                if (entry.pageSize > ((_a = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _a !== void 0 ? _a : VFSHTTP.defaultOptions.maxPageSize))\n                    throw new Error(`${entry.pageSize} is over the maximum configured ` +\n                        `${(_b = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _b !== void 0 ? _b : VFSHTTP.defaultOptions.maxPageSize}`);\n            }\n            const pageSize = BigInt(entry.pageSize);\n            const len = BigInt(msg.n);\n            const page = msg.offset / pageSize;\n            if (page * pageSize !== msg.offset)\n                debug['vfs'](`Read chunk ${msg.offset}:${msg.n} is not page-aligned`);\n            let pageStart = page * pageSize;\n            if (pageStart + pageSize < msg.offset + len)\n                throw new Error(`Read chunk ${msg.offset}:${msg.n} spans across a page-boundary`);\n            const cacheId = entry.id + '|' + page;\n            let data = cache.get(cacheId);\n            if (data instanceof Promise)\n                // This means that another thread has requested this segment\n                data = yield data;\n            if (typeof data === 'number') {\n                debug['cache'](`cache hit (multi-page segment) for ${msg.url}:${page}`);\n                // This page is present as a segment of a super-page\n                const newPageStart = BigInt(data) * pageSize;\n                data = cache.get(entry.id + '|' + data);\n                if (data instanceof Promise)\n                    data = yield data;\n                if (data instanceof Uint8Array) {\n                    // Not all subpages are valid, there are two possible cases\n                    // where a non-valid superpage can be referenced:\n                    // * the superpage was too big to fit in the cache\n                    // * the superpage was evicted before the subsegments\n                    pageStart = newPageStart;\n                }\n                else {\n                    data = undefined;\n                }\n            }\n            if (typeof data === 'undefined') {\n                debug['cache'](`cache miss for ${msg.url}:${page}`);\n                let chunkSize = entry.pageSize;\n                // If the previous page is in the cache, we double the page size\n                // This was the original page merging algorithm implemented by @phiresky\n                let prev = page > 0 && cache.get(entry.id + '|' + (Number(page) - 1));\n                if (prev) {\n                    if (prev instanceof Promise)\n                        prev = yield prev;\n                    if (typeof prev === 'number')\n                        prev = cache.get(entry.id + '|' + prev);\n                    if (prev instanceof Promise)\n                        prev = yield prev;\n                    if (prev instanceof Uint8Array) {\n                        // Valid superpage\n                        chunkSize = prev.byteLength * 2;\n                        debug['cache'](`downloading super page of size ${chunkSize}`);\n                    }\n                }\n                const pages = chunkSize / entry.pageSize;\n                // Download a new segment\n                debug['http'](`downloading page ${page} of size ${chunkSize} starting at ${pageStart}`);\n                const resp = fetch(msg.url, {\n                    method: 'GET',\n                    headers: Object.assign(Object.assign({}, ((_c = options === null || options === void 0 ? void 0 : options.headers) !== null && _c !== void 0 ? _c : VFSHTTP.defaultOptions.headers)), { 'Range': `bytes=${pageStart}-${pageStart + BigInt(chunkSize - 1)}` })\n                })\n                    .then((r) => r.arrayBuffer())\n                    .then((r) => new Uint8Array(r));\n                // We synchronously set a Promise in the cache in case another thread\n                // tries to read the same segment\n                cache.set(cacheId, resp);\n                // These point to the parent super-page and resolve at the same time as resp\n                for (let i = Number(page) + 1; i < Number(page) + pages; i++) {\n                    cache.set(entry.id + '|' + i, resp.then(() => Number(page)));\n                }\n                data = yield resp;\n                if (!(data instanceof Uint8Array) || data.length === 0)\n                    throw new Error(`Invalid HTTP response received: ${JSON.stringify(resp)}`);\n                // In case of a multiple-page segment, this is the parent super-page\n                cache.set(cacheId, data);\n                // These point to the parent super-page\n                for (let i = Number(page) + 1; i < Number(page) + pages; i++) {\n                    cache.set(entry.id + '|' + i, Number(page));\n                }\n            }\n            else {\n                debug['cache'](`cache hit for ${msg.url}:${page}`);\n            }\n            const pageOffset = Number(msg.offset - pageStart);\n            consumer.buffer.set(data.subarray(pageOffset, pageOffset + msg.n));\n            return 0;\n        });\n    },\n    // This is cached\n    xFilesize: function (msg, consumer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let entry = files.get(msg.url);\n            if (!entry)\n                throw new Error(`File ${msg.fid} not open`);\n            if (entry instanceof Promise)\n                entry = yield entry;\n            const out = new BigInt64Array(consumer.shm, 0, 1);\n            out[0] = entry.size;\n            return 0;\n        });\n    }\n};\nfunction workMessage({ data }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        debug['threads']('Received new work message', this, data);\n        let r;\n        try {\n            r = yield backendAsyncMethods[data.msg](data, this);\n            debug['threads']('operation successful', this, r);\n            Atomics.store(this.lock, 0, r);\n        }\n        catch (e) {\n            console.error(e);\n            Atomics.store(this.lock, 0, 1);\n        }\n        Atomics.notify(this.lock, 0);\n    });\n}\nglobalThis.onmessage = ({ data }) => {\n    var _a, _b, _c, _d;\n    debug['threads']('Received new control message', data);\n    switch (data.msg) {\n        case 'handshake':\n            {\n                const shm = new SharedArrayBuffer(((_a = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _a !== void 0 ? _a : VFSHTTP.defaultOptions.maxPageSize)\n                    + Int32Array.BYTES_PER_ELEMENT);\n                const lock = new Int32Array(shm, ((_b = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _b !== void 0 ? _b : VFSHTTP.defaultOptions.maxPageSize));\n                const buffer = new Uint8Array(shm, 0, ((_c = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _c !== void 0 ? _c : VFSHTTP.defaultOptions.maxPageSize));\n                Atomics.store(lock, 0, VFSHTTP.SYNC.HANDSHAKE);\n                consumers[data.id] = { id: data.id, port: data.port, shm, lock, buffer };\n                data.port.onmessage = workMessage.bind(consumers[data.id]);\n                postMessage({ msg: 'ack', id: data.id, shm, lock });\n            }\n            break;\n        case 'init':\n            options = data.options;\n            cache = new LRUCache({\n                maxSize: ((_d = options === null || options === void 0 ? void 0 : options.cacheSize) !== null && _d !== void 0 ? _d : VFSHTTP.defaultOptions.cacheSize) * 1024,\n                sizeCalculation: (value) => { var _a; return (_a = value.byteLength) !== null && _a !== void 0 ? _a : 4; }\n            });\n            break;\n        case 'close':\n            postMessage({ msg: 'ack' });\n            close();\n            break;\n        default:\n            throw new Error(`Invalid message received by backend: ${data}`);\n    }\n};\nif (typeof SharedArrayBuffer === 'undefined') {\n    throw new Error('SharedArrayBuffer is not available. ' +\n        'If your browser supports it, the webserver must send ' +\n        '\"Cross-Origin-Opener-Policy: same-origin \"' +\n        'and \"Cross-Origin-Embedder-Policy: require-corp\" headers.');\n}\n//# sourceMappingURL=vfs-http-worker.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [842], () => (__webpack_require__(559)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t559: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunksqlite_wasm_http\"] = self[\"webpackChunksqlite_wasm_http\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","defaultOptions","timeout","maxPageSize","cacheSize","headers","SYNC","debugOptions","debugSys","debug","d","includes","console","bind","swapNeeded","ab","ArrayBuffer","u8","Uint8Array","u16","Uint16Array","Error","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","e","rejected","result","done","then","apply","options","consumers","files","max","cache","nextId","backendAsyncMethods","xOpen","msg","this","entry","get","url","undefined","fetch","method","Object","assign","head","_a","warn","id","size","BigInt","pageSize","set","xAccess","consumer","Uint32Array","shm","r","xRead","_b","_c","n","offset","pageDataBuffer","buffer","pageData","data","i","length","ntoh16","delete","len","page","pageStart","cacheId","newPageStart","chunkSize","prev","Number","byteLength","pages","resp","arrayBuffer","JSON","stringify","pageOffset","subarray","xFilesize","fid","BigInt64Array","workMessage","Atomics","store","lock","error","notify","globalThis","onmessage","_d","SharedArrayBuffer","Int32Array","BYTES_PER_ELEMENT","port","postMessage","maxSize","sizeCalculation","close","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","j","keys","every","key","splice","definition","o","defineProperty","enumerable","f","chunkId","all","reduce","promises","u","g","Function","window","obj","prop","prototype","hasOwnProperty","call","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","replace","p","installedChunks","chunkLoadingGlobal","self","parentChunkLoadingFunction","push","moreModules","runtime","pop"],"sourceRoot":""}