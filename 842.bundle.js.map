{"version":3,"file":"842.bundle.js","mappings":"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","sources":["webpack://sqlite-wasm-http/./node_modules/lru-cache/index.mjs"],"sourcesContent":["const perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst hasAbortController = typeof AbortController === 'function'\n\n// minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\nconst AC = hasAbortController\n  ? AbortController\n  : class AbortController {\n      constructor() {\n        this.signal = new AS()\n      }\n      abort(reason = new Error('This operation was aborted')) {\n        this.signal.reason = this.signal.reason || reason\n        this.signal.aborted = true\n        this.signal.dispatchEvent({\n          type: 'abort',\n          target: this.signal,\n        })\n      }\n    }\n\nconst hasAbortSignal = typeof AbortSignal === 'function'\n// Some polyfills put this on the AC class, not global\nconst hasACAbortSignal = typeof AC.AbortSignal === 'function'\nconst AS = hasAbortSignal\n  ? AbortSignal\n  : hasACAbortSignal\n  ? AC.AbortController\n  : class AbortSignal {\n      constructor() {\n        this.reason = undefined\n        this.aborted = false\n        this._listeners = []\n      }\n      dispatchEvent(e) {\n        if (e.type === 'abort') {\n          this.aborted = true\n          this.onabort(e)\n          this._listeners.forEach(f => f(e), this)\n        }\n      }\n      onabort() {}\n      addEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners.push(fn)\n        }\n      }\n      removeEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners = this._listeners.filter(f => f !== fn)\n        }\n      }\n    }\n\nconst warned = new Set()\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache)\n  }\n}\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, method)\n    warn(code, `${method} method`, `cache.${instead}()`, get)\n  }\n}\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, field)\n    warn(code, `${field} property`, `cache.${instead}`, get)\n  }\n}\n\nconst emitWarning = (...a) => {\n  typeof process === 'object' &&\n  process &&\n  typeof process.emitWarning === 'function'\n    ? process.emitWarning(...a)\n    : console.error(...a)\n}\n\nconst shouldWarn = code => !warned.has(code)\n\nconst warn = (code, what, instead, fn) => {\n  warned.add(code)\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`\n  emitWarning(msg, 'DeprecationWarning', code, fn)\n}\n\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)\n\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\nconst getUintArray = max =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size)\n    this.fill(0)\n  }\n}\n\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return []\n    }\n    const UintArray = getUintArray(max)\n    this.heap = new UintArray(max)\n    this.length = 0\n  }\n  push(n) {\n    this.heap[this.length++] = n\n  }\n  pop() {\n    return this.heap[--this.length]\n  }\n}\n\nclass LRUCache {\n  constructor(options = {}) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      fetchContext,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n    const { length, maxAge, stale } =\n      options instanceof LRUCache ? {} : options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.max = max\n    this.maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.maxSize\n    this.sizeCalculation = sizeCalculation || length\n    if (this.sizeCalculation) {\n      if (!this.maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    this.fetchMethod = fetchMethod || null\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n\n    this.fetchContext = fetchContext\n    if (!this.fetchMethod && fetchContext !== undefined) {\n      throw new TypeError(\n        'cannot set fetchContext without fetchMethod'\n      )\n    }\n\n    this.keyMap = new Map()\n    this.keyList = new Array(max).fill(null)\n    this.valList = new Array(max).fill(null)\n    this.next = new UintArray(max)\n    this.prev = new UintArray(max)\n    this.head = 0\n    this.tail = 0\n    this.free = new Stack(max)\n    this.initialFill = 1\n    this.size = 0\n\n    if (typeof dispose === 'function') {\n      this.dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter\n      this.disposed = []\n    } else {\n      this.disposeAfter = null\n      this.disposed = null\n    }\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.maxSize !== 0) {\n        if (!isPosInt(this.maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale || !!stale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || maxAge || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n\n    if (stale) {\n      deprecatedOption('stale', 'allowStale')\n    }\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl')\n    }\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation')\n    }\n  }\n\n  getRemainingTTL(key) {\n    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0\n  }\n\n  initializeTTLTracking() {\n    this.ttls = new ZeroArray(this.max)\n    this.starts = new ZeroArray(this.max)\n\n    this.setItemTTL = (index, ttl, start = perf.now()) => {\n      this.starts[index] = ttl !== 0 ? start : 0\n      this.ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.isStale(index)) {\n            this.delete(this.keyList[index])\n          }\n        }, ttl + 1)\n        /* istanbul ignore else - unref() not supported on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n    }\n\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.statusTTL = (status, index) => {\n      if (status) {\n        status.ttl = this.ttls[index]\n        status.start = this.starts[index]\n        status.now = cachedNow || getNow()\n        status.remainingTTL = status.now + status.ttl - status.start\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        /* istanbul ignore else - not available on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      return this.ttls[index] === 0 || this.starts[index] === 0\n        ? Infinity\n        : this.starts[index] +\n            this.ttls[index] -\n            (cachedNow || getNow())\n    }\n\n    this.isStale = index => {\n      return (\n        this.ttls[index] !== 0 &&\n        this.starts[index] !== 0 &&\n        (cachedNow || getNow()) - this.starts[index] >\n          this.ttls[index]\n      )\n    }\n  }\n  updateItemAge(_index) {}\n  statusTTL(_status, _index) {}\n  setItemTTL(_index, _ttl, _start) {}\n  isStale(_index) {\n    return false\n  }\n\n  initializeSizeTracking() {\n    this.calculatedSize = 0\n    this.sizes = new ZeroArray(this.max)\n    this.removeItemSize = index => {\n      this.calculatedSize -= this.sizes[index]\n      this.sizes[index] = 0\n    }\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +\n              'must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.addItemSize = (index, size, status) => {\n      this.sizes[index] = size\n      if (this.maxSize) {\n        const maxSize = this.maxSize - this.sizes[index]\n        while (this.calculatedSize > maxSize) {\n          this.evict(true)\n        }\n      }\n      this.calculatedSize += this.sizes[index]\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.calculatedSize\n      }\n    }\n  }\n  removeItemSize(_index) {}\n  addItemSize(_index, _size) {}\n  requireSize(_k, _v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n  }\n\n  *indexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.tail; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.head) {\n          break\n        } else {\n          i = this.prev[i]\n        }\n      }\n    }\n  }\n\n  *rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.head; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.tail) {\n          break\n        } else {\n          i = this.next[i]\n        }\n      }\n    }\n  }\n\n  isValidIndex(index) {\n    return (\n      index !== undefined &&\n      this.keyMap.get(this.keyList[index]) === index\n    )\n  }\n\n  *entries() {\n    for (const i of this.indexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield [this.keyList[i], this.valList[i]]\n      }\n    }\n  }\n  *rentries() {\n    for (const i of this.rindexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield [this.keyList[i], this.valList[i]]\n      }\n    }\n  }\n\n  *keys() {\n    for (const i of this.indexes()) {\n      if (\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.keyList[i]\n      }\n    }\n  }\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      if (\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.keyList[i]\n      }\n    }\n  }\n\n  *values() {\n    for (const i of this.indexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.valList[i]\n      }\n    }\n  }\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.valList[i]\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  find(fn, getOptions) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions)\n      }\n    }\n  }\n\n  forEach(fn, thisp = this) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.keyList[i], this)\n    }\n  }\n\n  rforEach(fn, thisp = this) {\n    for (const i of this.rindexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.keyList[i], this)\n    }\n  }\n\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale')\n    return this.purgeStale\n  }\n\n  purgeStale() {\n    let deleted = false\n    for (const i of this.rindexes({ allowStale: true })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i])\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  dump() {\n    const arr = []\n    for (const i of this.indexes({ allowStale: true })) {\n      const key = this.keyList[i]\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      const entry = { value }\n      if (this.ttls) {\n        entry.ttl = this.ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - this.starts[i]\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.sizes) {\n        entry.size = this.sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  load(arr) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset.\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  dispose(_v, _k, _reason) {}\n\n  set(\n    k,\n    v,\n    {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      status,\n    } = {}\n  ) {\n    size = this.requireSize(k, v, size, sizeCalculation)\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case a background fetch is there already.\n      // in non-async cases, this is a no-op\n      this.delete(k)\n      return this\n    }\n    let index = this.size === 0 ? undefined : this.keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = this.newIndex()\n      this.keyList[index] = k\n      this.valList[index] = v\n      this.keyMap.set(k, index)\n      this.next[this.tail] = index\n      this.prev[index] = this.tail\n      this.tail = index\n      this.size++\n      this.addItemSize(index, size, status)\n      if (status) {\n        status.set = 'add'\n      }\n      noUpdateTTL = false\n    } else {\n      // update\n      this.moveToTail(index)\n      const oldVal = this.valList[index]\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set')\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set'])\n            }\n          }\n        }\n        this.removeItemSize(index)\n        this.valList[index] = v\n        this.addItemSize(index, size, status)\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking()\n    }\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl, start)\n    }\n    this.statusTTL(status, index)\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return this\n  }\n\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail\n    }\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false)\n    }\n    if (this.free.length !== 0) {\n      return this.free.pop()\n    }\n    // initial fill, just keep writing down the list\n    return this.initialFill++\n  }\n\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head]\n      this.evict(true)\n      return val\n    }\n  }\n\n  evict(free) {\n    const head = this.head\n    const k = this.keyList[head]\n    const v = this.valList[head]\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else {\n      this.dispose(v, k, 'evict')\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict'])\n      }\n    }\n    this.removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.keyList[head] = null\n      this.valList[head] = null\n      this.free.push(head)\n    }\n    this.head = this.next[head]\n    this.keyMap.delete(k)\n    this.size--\n    return head\n  }\n\n  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index)\n        }\n        if (status) status.has = 'hit'\n        this.statusTTL(status, index)\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  // like get(), but without any LRU updating or TTL expiration\n  peek(k, { allowStale = this.allowStale } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      const v = this.valList[index]\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v\n    }\n  }\n\n  backgroundFetch(k, index, options, context) {\n    const v = index === undefined ? undefined : this.valList[index]\n    if (this.isBackgroundFetch(v)) {\n      return v\n    }\n    const ac = new AC()\n    if (options.signal) {\n      options.signal.addEventListener('abort', () =>\n        ac.abort(options.signal.reason)\n      )\n    }\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n    const cb = (v, updateCache = false) => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      if (this.valList[index] === p) {\n        if (v === undefined) {\n          if (p.__staleWhileFetching) {\n            this.valList[index] = p.__staleWhileFetching\n          } else {\n            this.delete(k)\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n    const eb = er => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n    const fetchFail = er => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      if (this.valList[index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || p.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.valList[index] = p.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && p.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return p.__staleWhileFetching\n      } else if (p.__returned === p) {\n        throw er\n      }\n    }\n    const pcall = (res, rej) => {\n      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej)\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res()\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    p.__abortController = ac\n    p.__staleWhileFetching = v\n    p.__returned = null\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, p, { ...fetchOpts.options, status: undefined })\n      index = this.keyMap.get(k)\n    } else {\n      this.valList[index] = p\n    }\n    return p\n  }\n\n  isBackgroundFetch(p) {\n    return (\n      p &&\n      typeof p === 'object' &&\n      typeof p.then === 'function' &&\n      Object.prototype.hasOwnProperty.call(\n        p,\n        '__staleWhileFetching'\n      ) &&\n      Object.prototype.hasOwnProperty.call(p, '__returned') &&\n      (p.__returned === p || p.__returned === null)\n    )\n  }\n\n  // this takes the union of get() and set() opts, because it does both\n  async fetch(\n    k,\n    {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      fetchContext = this.fetchContext,\n      forceRefresh = false,\n      status,\n      signal,\n    } = {}\n  ) {\n    if (!this.fetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        this.statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = hasStale && isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  get(\n    k,\n    {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = {}\n  ) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.valList[index]\n      const fetching = this.isBackgroundFetch(value)\n      this.statusTTL(status, index)\n      if (this.isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          if (status) status.returnedStale = allowStale\n          return allowStale ? value : undefined\n        } else {\n          if (status) {\n            status.returnedStale =\n              allowStale && value.__staleWhileFetching !== undefined\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  connect(p, n) {\n    this.prev[n] = p\n    this.next[p] = n\n  }\n\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index]\n      } else {\n        this.connect(this.prev[index], this.next[index])\n      }\n      this.connect(this.tail, index)\n      this.tail = index\n    }\n  }\n\n  get del() {\n    deprecatedMethod('del', 'delete')\n    return this.delete\n  }\n\n  delete(k) {\n    let deleted = false\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.size === 1) {\n          this.clear()\n        } else {\n          this.removeItemSize(index)\n          const v = this.valList[index]\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else {\n            this.dispose(v, k, 'delete')\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete'])\n            }\n          }\n          this.keyMap.delete(k)\n          this.keyList[index] = null\n          this.valList[index] = null\n          if (index === this.tail) {\n            this.tail = this.prev[index]\n          } else if (index === this.head) {\n            this.head = this.next[index]\n          } else {\n            this.next[this.prev[index]] = this.next[index]\n            this.prev[this.next[index]] = this.prev[index]\n          }\n          this.size--\n          this.free.push(index)\n        }\n      }\n    }\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return deleted\n  }\n\n  clear() {\n    for (const index of this.rindexes({ allowStale: true })) {\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.keyList[index]\n        this.dispose(v, k, 'delete')\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete'])\n        }\n      }\n    }\n\n    this.keyMap.clear()\n    this.valList.fill(null)\n    this.keyList.fill(null)\n    if (this.ttls) {\n      this.ttls.fill(0)\n      this.starts.fill(0)\n    }\n    if (this.sizes) {\n      this.sizes.fill(0)\n    }\n    this.head = 0\n    this.tail = 0\n    this.initialFill = 1\n    this.free.length = 0\n    this.calculatedSize = 0\n    this.size = 0\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n  }\n\n  get reset() {\n    deprecatedMethod('reset', 'clear')\n    return this.clear\n  }\n\n  get length() {\n    deprecatedProperty('length', 'size')\n    return this.size\n  }\n\n  static get AbortController() {\n    return AC\n  }\n  static get AbortSignal() {\n    return AS\n  }\n}\n\nexport default LRUCache\n"],"names":["perf","performance","now","Date","AC","AbortController","constructor","this","signal","AS","abort","reason","Error","aborted","dispatchEvent","type","target","hasAbortSignal","AbortSignal","hasACAbortSignal","undefined","_listeners","e","onabort","forEach","f","addEventListener","ev","fn","push","removeEventListener","filter","warned","Set","deprecatedOption","opt","instead","code","shouldWarn","warn","LRUCache","deprecatedMethod","method","prototype","get","Object","getOwnPropertyDescriptor","emitWarning","a","process","console","error","has","what","add","isPosInt","n","Math","floor","isFinite","getUintArray","max","pow","Uint8Array","Uint16Array","Uint32Array","Number","MAX_SAFE_INTEGER","ZeroArray","Array","size","super","fill","Stack","UintArray","heap","length","pop","options","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","dispose","disposeAfter","noDisposeOnSet","noUpdateTTL","maxSize","maxEntrySize","sizeCalculation","fetchMethod","fetchContext","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchRejection","allowStaleOnFetchAbort","ignoreFetchAbort","maxAge","stale","TypeError","keyMap","Map","keyList","valList","next","prev","head","tail","free","initialFill","disposed","initializeSizeTracking","initializeTTLTracking","getRemainingTTL","key","Infinity","ttls","starts","setItemTTL","index","start","t","setTimeout","isStale","delete","unref","updateItemAge","statusTTL","status","cachedNow","getNow","remainingTTL","_index","_status","_ttl","_start","calculatedSize","sizes","removeItemSize","requireSize","k","v","isBackgroundFetch","addItemSize","evict","entrySize","totalCalculatedSize","_size","_k","_v","i","isValidIndex","indexes","rindexes","Symbol","iterator","entries","find","getOptions","value","__staleWhileFetching","thisp","call","rforEach","prune","purgeStale","deleted","dump","arr","entry","age","unshift","load","clear","set","_reason","maxEntrySizeExceeded","newIndex","moveToTail","oldVal","__abortController","oldValue","shift","val","peek","backgroundFetch","context","ac","fetchOpts","cb","updateCache","ignoreAbort","fetchAborted","fetchError","fetchAbortIgnored","fetchResolved","p","fetchUpdated","fetchFail","er","allowStaleAborted","noDelete","returnedStale","__returned","fetchDispatched","Promise","res","rej","then","fetchRejected","hasOwnProperty","async","forceRefresh","fetch","hasStale","staleVal","fetching","connect","del","reset","field","deprecatedProperty"],"sourceRoot":""}